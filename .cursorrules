- If there is an error, explain the cause of the error
- Do not omit details as much as possible
- All messages in the code should be in English

ã“ã®ãƒªãƒã‚¸ãƒˆãƒªã®åŸºæœ¬æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ã¯ä»¥ä¸‹ã§ã‚ã‚‹ã€‚
- TypeScript
    - React
    - Next.js
    - Tailwind CSS
- Rust
    - axum
    - sqlx
- MySQL(TiDB)
- aws

For *.md file
- Use Japanese
- Use PlantUML for diagrams
- markdownã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚¿ã‚¹ã‚¯ã‚’æ›¸ãå ´åˆã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ãã€‚ã‚¿ã‚¹ã‚¯ã®é€²è¡Œåº¦ã«å¿œã˜ã¦çµµæ–‡å­—ã‚’å¤‰ãˆã‚‹ã€‚
    - âœ… DONE
    - âœ… DONE
    - ğŸ”„ IN PROGRESS
    - ğŸ“ TODO
    - ğŸ“ TODO
    - ğŸ“ TODO

ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã¯`sqlx`ã‚’ä½¿ç”¨ã—ã¦ä½œæˆã™ã‚‹ã€‚
crateã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ `sqlx migrate add -r <name>`ã§ä½œæˆã§ãã‚‹ã€‚

For Cargo.toml file
- ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯`0.1.0`ã‹ã‚‰å§‹ã‚ã‚‹ã€‚
- rootã®Cargo.tomlã«æ›¸ã„ã¦ã‚ã‚‹crateã‚’åˆ©ç”¨ã™ã‚‹å ´åˆã¯`workspace = true`ã‚’è¨­å®šã™ã‚‹ã€‚

For *.rs file
You are an expert in Rust.

- Use `#[derive(Debug, Clone, PartialEq, Eq, EnumString, Display)]` for enums
- idã¯å…¨ã¦ULIDã‚’å…¨ã¦å°æ–‡å­—ã«ã—ãŸã‚‚ã®ã‚’ä½¿ç”¨ã™ã‚‹ã€‚def_id!(IdName, "prefix_")ã§ç”Ÿæˆã§ãã‚‹ã€‚
- Error Handling in Rust. use `errors::Result` for error handling.
```rust
use errors::Result;

fn sample() -> Result<()> {w
    Ok(())
}
```

- Use `#[tokio::test]` for testing async functions.
```rust
#[tokio::test]
async fn test_sample() {
    let result = sample().await;
    assert!(result.is_ok());
}
```



For *.tsx file
- As an expert in TypeScript, Node.js, Next.js App Router, React, Shadcn UI, Radix UI, and Tailwind CSS, write a web application that meets the following requirements:
- Code Style and Structure:
    - Write concise and technical TypeScript code.
    - Use functional and declarative programming patterns, avoiding classes.
    - Avoid code duplication, prioritizing iteration and modularization.
    - Use descriptive variable names including auxiliary verbs (e.g., `isLoading`, `hasError`).
    - Structure the file: exported components, subcomponents, helpers, static content, and types.
- Naming Conventions:
    - Use lowercase and dashes for directories (e.g., `components/auth-wizard`).
    - Prefer named exports for components.
- TypeScript Usage:
    - Use TypeScript for all code. Prefer interfaces over types.
    - Avoid enums, use maps instead.
    - Use functional components with TypeScript interfaces.
- Syntax and Formatting:
    - Use the `function` keyword for pure functions.
    - Avoid unnecessary curly braces in conditional statements, use concise syntax.
    - Use declarative JSX.
- UI and Styling:
    - Use Shadcn UI, Radix, and Tailwind for components and styling.
    - Implement responsive design with Tailwind CSS, using a mobile-first approach.
- Performance Optimization:
    - Minimize the use of `use client`, `useEffect`, and `setState`, prioritizing React Server Components (RSC).
    - Wrap client components with Suspense and provide fallbacks.
    - Use dynamic loading for non-critical components.
    - Optimize images: use WebP format, include size data, and implement lazy loading.
- Key Conventions:
    - Use `nuqs` for URL search parameter state management.
    - Optimize Web Vitals (LCP, CLS, FID).
    - Limit the use of `use client`.
    - Follow Next.js documentation for data fetching, rendering, and routing.
- Development Environment:
    - Install all necessary npm packages.
    - Ensure the application is fully functional and can run in development mode.
